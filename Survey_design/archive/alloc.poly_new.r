# This allocates tows (or anything really) for a straified random design.  
#This can be based on bottom type (or another polygon based non-continuous stratifying variable)
#####  DK August 26th, 2016
# Update history
# Commented, checked  and revised by DK August 2016 (Added in seed option to the function)
	
alloc.poly<-function(poly.lst,bounding.poly,ntows,bank.plot=NULL,mindist=1,pool.size=4,
                     repeated.tows=NULL,lplace='bottomleft',show.pool=F,seed = NULL)
{
	require(PSBmapping) || stop("You'll need to install PBSmapping if you wanna do this thang")
  source(paste(direct,"Assessment_fns/Survey_design/genran.r",sep=""))
  source(paste(direct,"Assessment_fns/Maps/ScallopMap.r",sep=""))
  
	# This ignores all warnings
	options(warn=-1)
	# create pool of random points, if we haven't specified the number of points the second element of the poly list needs to have an allocation table in
  # it so we can figure out the total number of tows.
	if(missing(ntows)) ntows<-sum(poly.lst[[2]]$allocation)
	# This tells use the number of pools, which is simply the total number of tows multiplied by the "pool.size", the higher we set pool.size the
	# more location that are generated by genran, later we will sample from this large number of potential sites and narrow it down to the 
	# appropriate number of locations.
	npool=ntows*pool.size
	
	# If the bounding polygon is specified 
	if(!missing(bounding.poly))
	{
		surveyed.polys<-poly.lst[[1]]
	} # end if(!missing(bounding.poly))
	
	# If the bounding polygon is missing you'll need to make it yourself basedon the supplied polydata
	if(missing(bounding.poly))
	{
	  # Get the poly data
	  surveyed.polys<-poly.lst[[1]]
	  # Using the points in the polyset detmine the shape of the polygon using the convex hull
	  bounding.poly<-poly.lst[[1]][chull(poly.lst[[1]]$X,poly.lst[[1]]$Y),]
		# Now make up the position and secondary ID's needed for PBSmapping
	  bounding.poly$POS<-1:nrow(bounding.poly)
		bounding.poly$SID<-1
	}
	# Make the bounding.poly a PBS projection for Latitude/longitude
	attr(bounding.poly,"projection")<-"LL"
	
	# Now generate the appropriate number of random points within this polygon.
	# This retuns the tow ID, X & Y coordinates and the nearest neighbour distance.
	#source(paste(direct,"Assessment_fns/Survey_design/genran.r",sep=""))
	pool.EventData <- genran(npool,bounding.poly,mindist=mindist,seed=seed)
	
	# Make a Poly ID object for each unique strata
	Poly.ID<-unique(poly.lst[[2]]$PID)
	# Grab the strata names
	strata<-as.character(unique(poly.lst[[2]]$PName))
	# Define a variable
	strataTows.lst<-NULL
	
	# if the allocation scheme is provided in the second element of the poly.lst use it to calculate the strata area
	if("allocation" %in% names(poly.lst[[2]]))
	{
	  # Get the allocation for each strata
		towsi<-with(poly.lst[[2]],tapply(allocation,PName,unique))
		# Combine the survey boundary with the Poly ID and strata name then make it a "LL" PBSmapping object
		strataPolys.dat<-merge(surveyed.polys,subset(poly.lst[[2]],select=c("PID","PName")))
		attr(strataPolys.dat,"projection")<-"LL"
		# Now calculate the strata Area for the polygons using only the Primary Polygon ID's
		strataArea<-calcArea(strataPolys.dat,1)
	} # end if("allocation" %in% names(poly.lst[[2]]))
	
	# if the allocation scheme hasn't been provided then you'll need to run this.
	else
	{
		# initialize some variables.
		strataPolys.lst<-NULL
		strataArea<-c()
		towsi<-c()
		
		# calculate area and proportional allocation
		for(i in 1:length(strata))
		{
		  # Get the strata Polygon ID's (names)
			strataPIDS<-poly.lst[[2]]$PID[poly.lst[[2]]$PName==strata[i]]
			# Create a temporary variable which is the surveyed.polygons that are part of the current strata.
			tmp<-subset(surveyed.polys,PID %in% strataPIDS)
			# If the surveyed polygon has a PID that is in the current strata run this
			if(nrow(tmp)>0)
			{
			  # Give the strata a name in the temp object
				tmp$PName<-strata[i]
				# This will combine polygons into one large polygon then make that a PBSmapping object
				strataPolys.lst[[i]]<-combinePolys(tmp)
				attr(strataPolys.lst[[i]],"projection")<-"LL"
				# Calculate the area of this strata
				strataArea[i]<-calcArea(strataPolys.lst[[i]],1)$area
				# Give it it's proper name
				names(strataArea)[i]<-strata[i]
				print(strata[i]) # print this name to the screen
			} # end if(nrow(tmp)>0)
		} # end for(i in 1:length(strata))
		
		# Remove NA's
		strataArea<-na.omit(strataArea)
		# Turn the strataPolys.lst into a data.frame
		strataPolys.dat<-do.call("rbind",strataPolys.lst)
		# Get the number of tows for each strata and round to nearest whole number
		towsi<-round(strataArea/sum(strataArea)*ntows)
		# Keep only the results for strata that have tows
		towsi<-towsi[towsi>0]
		# This is needed to correct for rounding error, the first strata will get more/less tows by maybe 1 or 2 depending on how the rounding occured
		towsi[1]<-ntows-sum(towsi[-1])
		# Get the names for the strata that have tows.
		strata<-names(towsi)
	} # end else
	
	# For the strata with tows 
	for(i in 1:length(strata))
	{
	  # Get tows generated in the genran function that are found within the current strata, this creates more tows then are allocated to a strata 
	  # these are then subset to the appropriate number of tows in the next step
		LocSet<-findPolys(pool.EventData,subset(strataPolys.dat,PName==strata[i]))
		# Create the final list of tows, this is a subset of the tows created by genran based on the allocation scheme calculated for towsi.
		strataTows.lst[[i]]<-data.frame(subset(pool.EventData,EID %in% LocSet$EID)[1:towsi[strata[i]],c("EID","X","Y")],Poly.ID=Poly.ID[i],STRATA=strata[i])
	} # end for(i in 1:length(strata))
	# Unwrap the strata tows list into a dataframe
	Tows<-do.call("rbind",strataTows.lst)
	# Give each tow an unique ID
	Tows$EID<-1:sum(towsi)
	# Have the rownames match the EID and then make the Tows object a PBSmapping object
	rownames(Tows)<-1:sum(towsi)
	attr(Tows,"projection")<-"LL"

	
	# If there are repeated tows this will randomly select stations from last years	survey (repeated.tows)
	if(!is.null(repeated.tows))
	{
		# Define a new variable
	  repeated.lst<-NULL
	  # Reset the names for the repeated tows
		names(repeated.tows)<-c("EID","X","Y","Poly.ID")
		# Give the repeated tows an unique number
		repeated.tows$EID<-repeated.tows$EID+1000
		# Get the ones that aren't NA's
		repeat.str<-poly.lst[[2]][!is.na(poly.lst[[2]]$repeats),]
		# Combine the tow information with the repeated tow information and make that a PBSmapping object
		tmp <- rbind(Tows[,-5],repeated.tows)
		attr(tmp,"projection")<-"LL"
		# Calculate the nearest neighbour distance
		# This converts UTM coordinates of the bounding.poly to Lat/Lon, creates a window around that bounding polygon then
		# within that polygon
		tmp$nndist <- nndist(as.ppp(subset(convUL(tmp),select=c('X','Y')),with(convUL(bounding.poly),owin(range(X),range(Y)))))
		repeated.tows<-subset(tmp,nndist>mindist&EID>1000,-5)
		for(i in 1:length(repeat.str$PID))
	  {
			str.tows<-subset(repeated.tows,Poly.ID==repeat.str$PID[i]) 
			repeated.lst[[i]]<-str.tows[sample(1:nrow(str.tows),repeat.str$repeats[repeat.str$PID==repeat.str$PID[i]]),]
			repeated.lst[[i]]$STRATA<-repeat.str$PName[repeat.str$PID==repeat.str$PID[i]]
		}
		repeated.tows<-do.call("rbind",repeated.lst)
		
		Tows<-list(new.tows=Tows, repeated.tows=repeated.tows)
	} # end if(!is.null(repeated.tows))

	# If you want to make the bank plot 
	if(!is.null(bank.plot))
	{
    #	source(paste(direct,"Assessment_fns/Maps/ScallopMap.r",sep=""))
    # Make the plot
	  ScallopMap(bank.plot,poly.lst=list(surveyed.polys,poly.lst[[2]]))
		# Make a background color for the points
	  bg.col<-tapply(poly.lst[[2]]$col,poly.lst[[2]]$PName,unique)
		# If there are no repeated tows do this
	  if(is.null(repeated.tows))addPoints(Tows,pch=21, cex=1,bg=bg.col[as.character(Tows$STRATA)])
		# if there are repeated tows add them
	  if(!is.null(repeated.tows))
		{
			addPoints(Tows$new.tows,pch=21, cex=1,bg=bg.col[as.character(Tows$new.tows$STRATA)])
			addPoints(Tows$repeated.tows,pch=24, cex=1,bg=bg.col[as.character(Tows$repeated.tows$STRATA[order(Tows$repeated.tows$EID)])])
		} # end if(!is.null(repeated.tows))
	  # If we want to show the results directly from the genran function we can show those here
		if(show.pool==T) addPoints(pool.EventData,pch=4,cex=0.4)
		# Add the appropriate legend to the figure.
	  if(!is.null(repeated.tows))legend(lplace,legend=names(bg.col[unique(as.character(Tows$new.tows$STRATA))]),pch=21,
		                                  pt.bg=bg.col[unique(as.character(Tows$new.tows$STRATA))],bty='n',cex=1, inset = .02)
	  
		if(is.null(repeated.tows))legend(lplace,legend=names(bg.col[unique(as.character(Tows$STRATA))]),pch=24,
		                                 pt.bg=bg.col[unique(as.character(Tows$STRATA))],bty='n',cex=1, inset = .02)

	} # end if(!is.null(bank.plot))
	
	# Turn the warnings back on.
	options(warn=0)
	# Return the results to the function calling this.
	return(list(Tows=Tows,Areas=strataArea))
	
} # end function

